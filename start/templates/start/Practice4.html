{% extends "otree/Page.html" %}
{% load otree static %}

{% block content %}

<script>
  // server â†’ JS
  window.suffixes      = {{ session.vars.suffixes|json }};
  // We keep allowedValues for validation logic, even if not shown in dropdown
  window.allowedValues = {{ session.vars.allowed_values|json }};
  window.page_settings = {{ settings|json }};
  
  // Right answers from Excel (e.g. ["3; the A", "2; the A and the B"])
  window.rightAnswers  = {{ settings.right_answer|json }} || [];
</script>

<style>
  [v-cloak] { display: none; }
  .input-group { max-width: fit-content; }
  .input-kids  { min-width: 200px; }
  /* Optional: styling for the suffix text to look more like a sentence */
  .input-group-text { background-color: transparent; border: none; font-weight: bold; }
</style>

<div id="app" v-cloak>

  <h1>[[ title ]]</h1>
  <div v-html="main_text"></div>

  <div class="text-center my-3" v-if="image_path">
    <img :src="image_path"
         :alt="title"
         style="max-width: 600px; width: 100%; height:auto;">
  </div>

  <div class="text-center">
    <ul class="list-group list-group-flush my-3">
      <li class="list-group-item d-flex"
          v-for="(item, itemIndex) in items"
          :key="itemIndex"
          style="flex-flow: nowrap;">
        <div class="input-group mb-3 d-flex align-items-baseline"
             style="flex-flow: nowrap;">

          <div v-for="(field, fieldIndex) in item.fields"
               :key="fieldIndex"
               class="align-items-baseline input-group mb-3 d-flex flex-nowrap">

            <input
              type="text"
              v-model.trim="field.value"
              class="form-control input-kids"
              :placeholder="`...`"
              autocomplete="off"
              @input="hideError"
            >
            <span class="input-group-text mx-2 text-nowrap">
              [[ field.suffix ]]
            </span>
          </div>

          <button @click.prevent="addItem"
                  type="button"
                  class="btn btn-outline-secondary"
                  style="flex-basis: 50px;"
                  :disabled="items.length === maxItems">+</button>

          <button @click.prevent="removeItem(itemIndex)"
                  type="button"
                  class="btn btn-outline-danger"
                  style="flex-basis: 50px;"
                  :disabled="items.length === minItems">-</button>
        </div>
      </li>
    </ul>

    <p v-if="error" class="alert alert-danger">
      [[ errorMessage || 'Please check your answers.' ]]
    </p>
  </div>

  <div class="text-center mt-4">
    <button :disabled="!isFormFilled"
            class="btn btn-primary btn-lg"
            type="button"
            @click="validateAndSubmit">
      Next
    </button>
  </div>

</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
const app = Vue.createApp({
  data() {
    const s           = window.page_settings   || {};
    const suffixes    = Array.isArray(window.suffixes)      ? window.suffixes      : [];
    const allowedVals = Array.isArray(window.allowedValues) ? window.allowedValues : [];
    
    // Normalize right answers for case-insensitive comparison
    const correctAnswers = (window.rightAnswers || []).map(ans => 
        String(ans).toLowerCase().split(';').map(part => part.trim()).join(';')
    );

    // Initial row setup
    const seedFields = suffixes.map((suffix, i) => ({
      value: '',
      suffix,
      // We keep allowedLower for validation if you want to enforce specific vocabulary
      allowedLower: Array.isArray(allowedVals[i])
        ? allowedVals[i].map(v => String(v).toLowerCase())
        : []
    }));

    // Image logic
    let image_path = s.full_image_path || s.image_url || '';
    if (!image_path && s.image) {
      const name = (typeof s.image === 'string' && s.image.includes('.'))
        ? s.image
        : `${s.image}.png`;
      image_path = `/static/start/practice/${name}`;
    }

    return {
      title: s.title || 'Practice',
      main_text: s.main_text || '',
      image_path,

      allowedValues: allowedVals,
      suffixes,
      correctAnswers,
      items: [{ fields: seedFields }],

      maxItems: 5,
      minItems: 1,

      error: false,
      errorMessage: '',
    };
  },

  computed: {
    // Just checks if fields are not empty to enable button
    isFormFilled() {
      return this.items.every(item =>
        item.fields.every(f => f.value && f.value.trim() !== '')
      );
    },
  },

  methods: {
    // Check if input matches allowed vocabulary (Optional: remove this check if you want free text)
    isValidGrammar() {
      return this.items.every(item =>
        item.fields.every(field => {
          const allowed = field.allowedLower;
          if (!allowed || !allowed.length) return true; // No restriction if list empty
          return allowed.includes(String(field.value).trim().toLowerCase());
        })
      );
    },

    // Check if input matches the CORRECT answer from Excel
    isCorrectAnswer() {
      // Join user inputs with semicolon to match Excel format (e.g. "3; the a")
      if (this.items.length === 0) return false;

      // We only validate the first row against the right answer for practice
      const userString = this.items[0].fields
          .map(f => String(f.value).trim().toLowerCase())
          .join(';');

      return this.correctAnswers.includes(userString);
    },

    validateAndSubmit() {
      // 1. Check Grammar (Vocabulary)
      // If you want to allow ANY text as long as it matches the right answer, 
      // you can remove this block. Currently, it enforces the Excel "allowed_values".
      if (!this.isValidGrammar()) {
        this.error = true;
        this.errorMessage = 'Please use the standard terminology defined for this task.';
        return;
      }

      // 2. Check Logic (Right Answer)
      if (!this.isCorrectAnswer()) {
        this.error = true;
        this.errorMessage = 'That description is not correct for this image. Please try again.';
        return;
      }

      this.error = false;

      // Submit
      const outerForm = document.querySelector('form');
      if (outerForm) outerForm.submit();
    },

    addItem() {
      if (this.items.length >= this.maxItems) return;

      const fields = this.suffixes.map((suffix, i) => ({
        value: '',
        suffix,
        allowedLower: Array.isArray(this.allowedValues[i])
          ? this.allowedValues[i].map(v => String(v).toLowerCase())
          : []
      }));
      this.items.push({ fields });
    },

    removeItem(index) {
      if (this.items.length > this.minItems) {
        this.items.splice(index, 1);
      }
    },

    hideError() {
      this.error = false;
    },
  },
});

app.config.compilerOptions.delimiters = ['[[', ']]'];
app.mount('#app');
</script>

{% endblock %}
