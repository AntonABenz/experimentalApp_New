{% extends "otree/Page.html" %}
{% load otree static %}

{% block content %}

<script>
  // expose server vars
  window.suffixes      = {{ session.vars.suffixes|json }};
  window.allowedValues = {{ session.vars.allowed_values|json }};
  window.page_settings = {{ settings|json }};
</script>

<style>
  [v-cloak] { display: none; }
  .input-group { max-width: fit-content; }
  .input-kids { min-width: 200px; }
  .input-marbles { min-width: 200px; }
</style>

<div id="app" v-cloak>

  <h1>[[ title ]]</h1>
  <div v-html="main_text"></div>

  <div class="text-center my-3">
    <div class="image">
      <img :src="image_path"
           :alt="title"
           :width="500"
           style="max-width: 600px; width: 100%; height:auto;">
    </div>
  </div>

  <!-- OPTIONS LEGEND: what can be typed into each field -->
  <div class="my-3">
    <h5>What you can type into each text field</h5>
    <table class="table table-sm">
      <thead>
        <tr>
          <th>First text field</th>
          <th>Second text field</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="rowIdx in maxOptionsRows" :key="rowIdx">
          <td>
            [[ allowedValues[0] && allowedValues[0][rowIdx - 1] ? allowedValues[0][rowIdx - 1] : '' ]]
          </td>
          <td>
            [[ allowedValues[1] && allowedValues[1][rowIdx - 1] ? allowedValues[1][rowIdx - 1] : '' ]]
          </td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- INPUT INTERFACE -->
  <div class="text-center">
    <ul class="list-group list-group-flush my-3">
      <li class="list-group-item d-flex"
          v-for="(item, itemIndex) in items"
          :key="itemIndex"
          style="flex-flow: nowrap;">
        <div class="input-group mb-3 d-flex align-items-baseline"
             style="flex-flow: nowrap;">
          <div v-for="(field, fieldIndex) in item.fields"
               :key="fieldIndex"
               class="align-items-baseline input-group mb-3 d-flex flex-nowrap">
            <input type="text"
                   v-model.trim="field.value"
                   class="form-control input-kids"
                   :placeholder="`Field ${fieldIndex+1}`"
                   required
                   @input="hideError">
            <span class="input-group-text mx-3 text-nowrap">
              [[ field.suffix ]]
            </span>
          </div>

          <button @click.prevent="addItem"
                  type="button"
                  class="btn btn-success"
                  style="flex-basis: 75px;"
                  :disabled="items.length === maxItems">+</button>

          <button @click.prevent="removeItem(itemIndex)"
                  type="button"
                  class="btn btn-danger"
                  style="flex-basis: 75px;"
                  :disabled="items.length === minItems">-</button>
        </div>
      </li>
    </ul>

    <p v-if="error" class="alert alert-danger">
      [[ errorMessage || 'Please check your answers.' ]]
    </p>
  </div>

  <!-- IMPORTANT: this button just calls validate(), we submit the outer oTree form there -->
  <button :disabled="!isFormComplete"
          class="btn btn-primary"
          type="button"
          @click="validate">
    Next
  </button>

</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
const app = Vue.createApp({
  data() {
    const s            = window.page_settings || {};
    const suffixes     = Array.isArray(window.suffixes) ? window.suffixes : [];
    const allowedVals  = Array.isArray(window.allowedValues) ? window.allowedValues : [];

    // initial row
    const seedFields = suffixes.map((suffix, i) => ({
      value: '',
      suffix,
      // lowercased allowed values for this field
      allowedValues: Array.isArray(allowedVals[i])
        ? allowedVals[i].map(v => String(v).toLowerCase())
        : []
    }));

    // image path (prefer full_image_path)
    let image_path = s.full_image_path || s.image_url || '';
    if (!image_path && s.image) {
      const name = (typeof s.image === 'string' && s.image.includes('.'))
        ? s.image
        : `${s.image}.png`;
      image_path = `/static/start/practice/${name}`;
    }
    if (!image_path) {
      image_path = 'https://picsum.photos/200/300?text=No+Image';
    }

    return {
      title: s.title || 'Practice',
      main_text: s.main_text || '',
      image_path,

      allowedValues: allowedVals,

      suffixes,
      items: [{ fields: seedFields }],

      maxItems: 5,
      minItems: 1,

      error: false,
      errorMessage: '',
    };
  },

  computed: {
    // show enough rows in the legend for all options
    maxOptionsRows() {
      const a = this.allowedValues[0] ? this.allowedValues[0].length : 0;
      const b = this.allowedValues[1] ? this.allowedValues[1].length : 0;
      return Math.max(a, b);
    },

    isFormFull() {
      return this.items.every(item =>
        item.fields.every(f => f.value !== null && f.value !== undefined && f.value !== '')
      );
    },

    // For this page we only require all fields filled, not matching a predefined answer.
    isFormComplete() {
      return this.isFormFull;
    },

    // normalized user inputs (lowercased)
    flattenValues() {
      return this.items.map(item =>
        item.fields.map(field =>
          String(field.value).trim().replace(/\s+/g, ' ').toLowerCase()
        )
      );
    }
  },

  methods: {
    validate() {
      if (!this.isValid()) {
        this.error = true;
        this.errorMessage = 'Please use only the allowed phrases shown above.';
        return;
      }

      this.error = false;

      // submit the outer oTree form (from otree/Page.html)
      const outerForm = document.querySelector('form');
      if (outerForm) outerForm.submit();
    },

    // For this "what you can type" practice page:
    // each field must contain one of its allowedValues; no strict solution pattern.
    isValid() {
      return this.items.every(item =>
        item.fields.every((field, i) => {
          const allowed = Array.isArray(field.allowedValues) ? field.allowedValues : [];
          const v = String(field.value).trim().toLowerCase();
          return allowed.length === 0 || allowed.includes(v);
        })
      );
    },

    addItem() {
      if (this.items.length >= this.maxItems) return;

      const suffixes    = this.suffixes;
      const allowedVals = this.allowedValues;

      const fields = suffixes.map((suffix, i) => ({
        value: '',
        suffix,
        allowedValues: Array.isArray(allowedVals[i])
          ? allowedVals[i].map(v => String(v).toLowerCase())
          : []
      }));

      this.items.push({ fields });
    },

    removeItem(index) {
      if (this.items.length > this.minItems) {
        this.items.splice(index, 1);
      }
    },

    hideError() {
      this.error = false;
    },
  },
});

app.config.compilerOptions.delimiters = ['[[', ']]'];
app.mount('#app');
</script>

{% endblock %}
